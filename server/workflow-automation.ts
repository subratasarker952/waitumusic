import { db } from './db';
import * as schema from '@shared/schema';
import { eq, and } from 'drizzle-orm';
import { generateContractPDF, generateTechnicalRiderPDF } from './contracts/pdf-generator';
import { sendEmail } from './emailService';

export class WorkflowAutomation {
  // Auto-generate contracts when booking is confirmed
  async generateBookingContract(bookingId: number) {
    try {
      // Get booking details
      const [booking] = await db
        .select()
        .from(schema.bookings)
        .where(eq(schema.bookings.id, bookingId))
        .limit(1);
      
      if (!booking) throw new Error('Booking not found');
      
      // Get all assigned talent
      const assignments = await db
        .select({
          userId: schema.bookingAssignmentsMembers.userId,
          roleId: schema.bookingAssignmentsMembers.roleInBooking,
          isMainTalent: schema.bookingAssignmentsMembers.isMainBookedTalent,
          userName: schema.users.fullName,
          userEmail: schema.users.email
        })
        .from(schema.bookingAssignmentsMembers)
        .innerJoin(schema.users, eq(schema.bookingAssignmentsMembers.userId, schema.users.id))
        .where(
          and(
            eq(schema.bookingAssignmentsMembers.bookingId, bookingId),
            eq(schema.bookingAssignmentsMembers.status, 'active')
          )
        );
      
      // Create booking agreement for booker
      const [bookingAgreement] = await db.insert(schema.contracts).values({
        bookingId,
        contractType: 'booking_agreement',
        status: 'draft',
        createdByUserId: booking.bookerUserId,
        title: `Booking Agreement - ${booking.eventName}`,
        content: this.generateBookingAgreementContent(booking, assignments),
        metadata: {
          autoGenerated: true,
          generatedAt: new Date().toISOString(),
          totalTalent: assignments.length
        }
      }).returning();
      
      // Create performance contracts for each talent
      for (const assignment of assignments) {
        await db.insert(schema.contracts).values({
          bookingId,
          contractType: 'performance_contract',
          status: 'draft',
          createdByUserId: booking.bookerUserId,
          assignedToUserId: assignment.userId,
          title: `Performance Contract - ${assignment.userName}`,
          content: this.generatePerformanceContractContent(booking, assignment),
          metadata: {
            autoGenerated: true,
            talentRole: assignment.roleId,
            isMainTalent: assignment.isMainTalent
          }
        });
      }
      
      // Send notifications
      await this.notifyContractGeneration(booking, assignments);
      
      return bookingAgreement;
    } catch (error) {
      console.error('Error generating booking contract:', error);
      throw error;
    }
  }
  
  // Auto-assign regular band members when artist is booked
  async autoAssignBandMembers(bookingId: number, artistUserId: number) {
    try {
      // Get artist's regular band configuration
      const regularBand = await db
        .select()
        .from(schema.artistBandMembers)
        .where(eq(schema.artistBandMembers.artistUserId, artistUserId));
      
      // Auto-assign each band member
      for (const member of regularBand) {
        await db.insert(schema.bookingAssignmentsMembers).values({
          bookingId,
          userId: member.musicianUserId,
          roleInBooking: member.defaultRole || 6, // Default to musician
          assignmentType: 'auto',
          assignedBy: artistUserId,
          status: 'pending', // Requires confirmation
          selectedTalent: member.primaryInstrumentId,
          metadata: {
            autoAssigned: true,
            reason: 'regular_band_member'
          }
        });
      }
      
      return regularBand.length;
    } catch (error) {
      console.error('Error auto-assigning band members:', error);
      return 0;
    }
  }
  
  // Generate technical rider when all talent is confirmed
  async generateTechnicalRider(bookingId: number) {
    try {
      // Get all confirmed assignments with instruments
      const confirmedTalent = await db
        .select({
          userId: schema.bookingAssignmentsMembers.userId,
          userName: schema.users.fullName,
          instrumentId: schema.bookingAssignmentsMembers.selectedTalent,
          instrumentName: schema.allInstruments.name,
          instrumentSpecs: schema.allInstruments.technicalSpecs,
          mixerGroup: schema.allInstruments.mixerGroup,
          assignedChannel: schema.bookingAssignmentsMembers.assignedChannel
        })
        .from(schema.bookingAssignmentsMembers)
        .innerJoin(schema.users, eq(schema.bookingAssignmentsMembers.userId, schema.users.id))
        .leftJoin(schema.allInstruments, eq(schema.bookingAssignmentsMembers.selectedTalent, schema.allInstruments.id))
        .where(
          and(
            eq(schema.bookingAssignmentsMembers.bookingId, bookingId),
            eq(schema.bookingAssignmentsMembers.status, 'active')
          )
        );
      
      // Get hospitality requirements for each talent
      const hospitalityReqs = await this.gatherHospitalityRequirements(bookingId);
      
      // Create technical rider document
      const [technicalRider] = await db.insert(schema.documents).values({
        fileName: `Technical Rider - Booking #${bookingId}`,
        fileUrl: `/api/documents/technical-rider/${bookingId}`,
        documentType: 'technical_rider',
        bookingId,
        status: 'draft',
        uploadedBy: booking.bookerUserId

      }).returning();
      
      // Store technical rider content in technical_riders table
      await db.insert(schema.technicalRiders).values({
        bookingId,
        artistTechnicalSpecs: {},
        musicianTechnicalSpecs: {},
        equipmentRequirements: {
          stageLayout: await this.generateStageLayout(confirmedTalent),
          audioRequirements: this.generateAudioRequirements(confirmedTalent),
          channelList: this.generateChannelList(confirmedTalent)
        },
        stageRequirements: {},
        lightingRequirements: {},
        soundRequirements: {},
        additionalNotes: `Auto-generated on ${new Date().toISOString()}`
      });
      
      return technicalRider;
    } catch (error) {
      console.error('Error generating technical rider:', error);
      throw error;
    }
  }
  
  // Helper methods
  private generateBookingAgreementContent(booking: any, assignments: any[]) {
    return {
      parties: {
        booker: booking.bookerUserId,
        talent: assignments.map(a => ({ userId: a.userId, role: a.roleId }))
      },
      event: {
        name: booking.eventName,
        date: booking.eventDate,
        venue: booking.venueName,
        address: booking.venueAddress
      },
      terms: {
        totalBudget: booking.totalBudget,
        paymentSchedule: booking.paymentSchedule || 'standard',
        cancellationPolicy: 'standard'
      }
    };
  }
  
  private generatePerformanceContractContent(booking: any, assignment: any) {
    return {
      performer: {
        userId: assignment.userId,
        name: assignment.userName,
        role: assignment.roleId
      },
      performance: {
        eventName: booking.eventName,
        date: booking.eventDate,
        venue: booking.venueName,
        duration: booking.performanceDuration || '2 hours'
      },
      compensation: {
        amount: this.calculateTalentFee(booking.totalBudget, assignment),
        paymentMethod: 'bank_transfer',
        paymentSchedule: '50% advance, 50% after performance'
      }
    };
  }
  
  private calculateTalentFee(totalBudget: number, assignment: any): number {
    // Simple calculation - would be more complex in production
    if (assignment.isMainTalent) {
      return totalBudget * 0.4; // 40% for main talent
    }
    return totalBudget * 0.1; // 10% for supporting talent
  }
  
  private async gatherHospitalityRequirements(bookingId: number) {
    // Gather from talent profiles and booking-specific requirements
    const requirements = await db
      .select()
      .from(schema.hospitalityRequirements)
      .where(eq(schema.hospitalityRequirements.bookingId, bookingId));
    
    return requirements;
  }
  
  private async generateStageLayout(talent: any[]) {
    // Auto-generate stage positions based on instrument types
    const layout = {
      stageWidth: 30,
      stageDepth: 20,
      positions: talent.map((t, index) => ({
        talentId: t.userId,
        instrumentId: t.instrumentId,
        position: this.calculateStagePosition(t.mixerGroup, index),
        requiresPower: true,
        monitorMix: index + 1
      }))
    };
    
    return layout;
  }
  
  private calculateStagePosition(mixerGroup: string, index: number) {
    // Position based on instrument group
    const positions: Record<string, { x: number, y: number }> = {
      'Drums': { x: 15, y: 15 },
      'Bass': { x: 10, y: 10 },
      'Guitar': { x: 20, y: 10 },
      'Keys': { x: 5, y: 10 },
      'Vocals': { x: 15, y: 5 }
    };
    
    return positions[mixerGroup] || { x: 5 + (index * 5), y: 10 };
  }
  
  private generateAudioRequirements(talent: any[]) {
    const requirements = {
      mixerChannels: talent.filter(t => t.assignedChannel).length,
      monitorMixes: Math.ceil(talent.length / 2),
      microphoneList: talent
        .filter(t => t.instrumentSpecs?.requiresMic)
        .map(t => ({
          channel: t.assignedChannel,
          type: t.instrumentSpecs.micType || 'SM58',
          stand: t.instrumentSpecs.standType || 'boom'
        }))
    };
    
    return requirements;
  }
  
  private generateChannelList(talent: any[]) {
    return talent
      .filter(t => t.assignedChannel)
      .sort((a, b) => a.assignedChannel - b.assignedChannel)
      .map(t => ({
        channel: t.assignedChannel,
        instrument: t.instrumentName,
        performer: t.userName,
        inputType: t.instrumentSpecs?.inputType || 'XLR',
        phantomPower: t.instrumentSpecs?.requiresPhantom || false
      }));
  }
  
  private async notifyContractGeneration(booking: any, assignments: any[]) {
    // Send email notifications
    const notifications = [];
    
    // Notify booker
    notifications.push(
      sendEmail({
        to: booking.bookerEmail,
        subject: `Contracts Ready - ${booking.eventName}`,
        html: `
          <h2>Contracts Ready for ${booking.eventName}</h2>
          <p>All contracts have been generated for your booking.</p>
          <p>Total contracts created: ${assignments.length + 1}</p>
          <p>Please log in to review and sign the contracts.</p>
        `
      })
    );
    
    // Notify each talent
    for (const assignment of assignments) {
      notifications.push(
        sendEmail({
          to: assignment.userEmail,
          subject: `Performance Contract - ${booking.eventName}`,
          html: `
            <h2>Your Performance Contract is Ready</h2>
            <p>Hello ${assignment.userName},</p>
            <p>Your performance contract for ${booking.eventName} has been generated.</p>
            <p>Please log in to review and sign your contract.</p>
          `
        })
      );
    }
    
    await Promise.all(notifications);
  }
}

export const workflowAutomation = new WorkflowAutomation();